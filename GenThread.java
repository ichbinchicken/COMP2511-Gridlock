import java.util.*;
/**
 * GradLock Project
 * @author Michael Hamilton
 * Multithreaded Generation of puzzles
 * Generates them then adds to queue
 */
public class GenThread implements Runnable
{
	ArrayList<BoundedQueue<Puzzle>> queueList;
	private BoundedQueue<Puzzle> queue=null;
	private int count;

	private int size;
	private int minMoves=Difficulty.SC.getMoves();

	/**
	 * Constructor of GenThread
	 * @param queueList a list of the bounded queues containing puzzles
	 * @param count the number of puzzles generated by a thread
	 * @param size the size of board
	 * @param minMoves the number of minimum moves
	 * @pre queueList != null
	 * @post none
	 */
	public GenThread(ArrayList<BoundedQueue<Puzzle>> queueList, int count, int size, int minMoves) {
		System.out.println("New Thread");
		this.queueList = queueList;
		this.count = count;
		this.size=size;
		this.minMoves=minMoves;
	}

	/**
	 * check the queue is full or not
	 * @return true for full, false for the other way round
	 */
	private boolean queueListFull() {
		for(BoundedQueue<Puzzle> q: queueList) {
			if(q.isFull()==false) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Find lowest difficulty of non-full queue
	 * @return lowest difficulty 
	 */
	private Difficulty findSmallestQueue() {
		for(int i=0;i<queueList.size();i++) {
			queue = queueList.get(i);
			if(queue.isFull()==false) {
				switch(i) {
				case 0: return Difficulty.SC;
				case 1: return Difficulty.HSC;
				case 2: return Difficulty.BACH;
				case 3: return Difficulty.MASTERS;
				case 4: return Difficulty.PHD;
				//case 5: return Difficulty.ULTRAPHD;
				
				}
			}
		}
		return null;
	}


	/* (non-Javadoc)
	 * @see java.lang.Runnable#run()
	 * Continuously generate puzzles
	 * Put puzzle on difficulty queue
	 * IF queue is full increase number of minimal moves (so wont generate those boards)
	 * If number of boards generated = count - return
	 * When all queues are full sleep
	 */
	public void run() {
		Thread.currentThread().setPriority(Thread.MIN_PRIORITY);

		int i=1;

		try {

			while(i<count || count==-1) {
				Difficulty diff = findSmallestQueue();
				minMoves=0;
				if(diff!=null) {
					minMoves=diff.getMoves();
				}
				
				if(!queueListFull()){ 
					Puzzle puzzle = new Puzzle(size);
					int moves= puzzle.GeneratePuzzle(minMoves);
					if(moves>=Difficulty.PHD.getMoves()) {
						queue = queueList.get(4);
					}
					else if(moves>=Difficulty.MASTERS.getMoves()) {
						queue = queueList.get(3);
					}				
					else if(moves>=Difficulty.BACH.getMoves()) {
						queue = queueList.get(2);
					}
					else if(moves>=Difficulty.HSC.getMoves()) {
						queue = queueList.get(1);
					}
					else if(moves>=Difficulty.SC.getMoves()) {
						queue = queueList.get(0);
					}
					else {
						continue;
					}
					if(!queue.isFull()) {
						queue.add(puzzle);
						//System.out.println(moves);
						i++;
						//System.out.println("Thread i "+i +"Count"+count);
					}
					Thread.sleep((int) (Math.random() * DELAY));
				}
				else{
					//System.out.println("Thread Sleeping");
					Thread.sleep((int) (10000 * Math.random()));
					//System.out.println("Thread Wakeup");
				}
			}
			System.out.println("End Thread");
		}
	catch (InterruptedException exception){	
	}
	};
	   private static final int DELAY = 10;
}